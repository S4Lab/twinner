/*********************                                                        */
/** kind.h
 **
 ** Copyright 2010-2013  New York University and The University of Iowa,
 ** and as below.
 **
 ** This header file automatically generated by:
 **
 **     /home/behnam/installation-area/AUR/cvc4/src/cvc4-1.3/builds/x86_64-unknown-linux-gnu/default/../../../src/expr/mkkind /home/behnam/installation-area/AUR/cvc4/src/cvc4-1.3/builds/x86_64-unknown-linux-gnu/default/../../../src/expr/kind_template.h /home/behnam/installation-area/AUR/cvc4/src/cvc4-1.3/builds/x86_64-unknown-linux-gnu/default/../../../src/theory/builtin/kinds /home/behnam/installation-area/AUR/cvc4/src/cvc4-1.3/builds/x86_64-unknown-linux-gnu/default/../../../src/theory/booleans/kinds /home/behnam/installation-area/AUR/cvc4/src/cvc4-1.3/builds/x86_64-unknown-linux-gnu/default/../../../src/theory/uf/kinds /home/behnam/installation-area/AUR/cvc4/src/cvc4-1.3/builds/x86_64-unknown-linux-gnu/default/../../../src/theory/arith/kinds /home/behnam/installation-area/AUR/cvc4/src/cvc4-1.3/builds/x86_64-unknown-linux-gnu/default/../../../src/theory/bv/kinds /home/behnam/installation-area/AUR/cvc4/src/cvc4-1.3/builds/x86_64-unknown-linux-gnu/default/../../../src/theory/arrays/kinds /home/behnam/installation-area/AUR/cvc4/src/cvc4-1.3/builds/x86_64-unknown-linux-gnu/default/../../../src/theory/datatypes/kinds /home/behnam/installation-area/AUR/cvc4/src/cvc4-1.3/builds/x86_64-unknown-linux-gnu/default/../../../src/theory/quantifiers/kinds /home/behnam/installation-area/AUR/cvc4/src/cvc4-1.3/builds/x86_64-unknown-linux-gnu/default/../../../src/theory/rewriterules/kinds /home/behnam/installation-area/AUR/cvc4/src/cvc4-1.3/builds/x86_64-unknown-linux-gnu/default/../../../src/theory/idl/kinds /home/behnam/installation-area/AUR/cvc4/src/cvc4-1.3/builds/x86_64-unknown-linux-gnu/default/../../../src/theory/strings/kinds
 **
 ** for the CVC4 project.
 **/

/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */

/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */
/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT ! */

/* Edit the template file instead:                     */
/* /home/behnam/installation-area/AUR/cvc4/src/cvc4-1.3/builds/x86_64-unknown-linux-gnu/default/../../../src/expr/kind_template.h */

/*********************                                                        */
/*! \file kind_template.h
 ** \verbatim
 ** Original author: Morgan Deters
 ** Major contributors: Dejan Jovanovic
 ** Minor contributors (to current version): none
 ** This file is part of the CVC4 project.
 ** Copyright (c) 2009-2013  New York University and The University of Iowa
 ** See the file COPYING in the top-level source directory for licensing
 ** information.\endverbatim
 **
 ** \brief Template for the Node kind header
 **
 ** Template for the Node kind header.
 **/

#include <cvc4/cvc4_public.h>

#ifndef __CVC4__KIND_H
#define __CVC4__KIND_H

#include <iostream>
#include <sstream>

#include <cvc4/util/exception.h>

namespace CVC4 {
namespace kind {

enum Kind_t {

  UNDEFINED_KIND = -1, /**< undefined */
  NULL_EXPR, /**< Null kind */

  /* from builtin */
  SORT_TAG, /**< sort tag */
  SORT_TYPE, /**< sort type */
  UNINTERPRETED_CONSTANT, /**< The kind of expressions representing uninterpreted constants */
  ABSTRACT_VALUE, /**< The kind of expressions representing abstract values (other than uninterpreted sort constants) */
  BUILTIN, /**< The kind of expressions representing built-in operators */
  FUNCTION, /**< function */
  APPLY, /**< defined function application */
  EQUAL, /**< equality */
  DISTINCT, /**< disequality */
  VARIABLE, /**< variable */
  BOUND_VARIABLE, /**< bound variable */
  SKOLEM, /**< skolem var */
  SEXPR, /**< a symbolic expression */
  LAMBDA, /**< lambda */
  CHAIN, /**< chained operator */
  CHAIN_OP, /**< the chained operator */
  TYPE_CONSTANT, /**< basic types */
  FUNCTION_TYPE, /**< function type */
  SEXPR_TYPE, /**< symbolic expression type */
  SUBTYPE_TYPE, /**< predicate subtype */

  /* from booleans */
  CONST_BOOLEAN, /**< truth and falsity */
  NOT, /**< logical not */
  AND, /**< logical and */
  IFF, /**< logical equivalence */
  IMPLIES, /**< logical implication */
  OR, /**< logical or */
  XOR, /**< exclusive or */
  ITE, /**< if-then-else */

  /* from uf */
  APPLY_UF, /**< uninterpreted function application */
  CARDINALITY_CONSTRAINT, /**< cardinality constraint */
  COMBINED_CARDINALITY_CONSTRAINT, /**< combined cardinality constraint */

  /* from arith */
  PLUS, /**< arithmetic addition */
  MULT, /**< arithmetic multiplication */
  MINUS, /**< arithmetic binary subtraction operator */
  UMINUS, /**< arithmetic unary negation */
  DIVISION, /**< real division (user symbol) */
  DIVISION_TOTAL, /**< real division with interpreted division by 0 (internal symbol) */
  INTS_DIVISION, /**< ints division (user symbol) */
  INTS_DIVISION_TOTAL, /**< ints division with interpreted division by 0 (internal symbol) */
  INTS_MODULUS, /**< ints modulus (user symbol) */
  INTS_MODULUS_TOTAL, /**< ints modulus with interpreted division by 0 (internal symbol) */
  ABS, /**< absolute value */
  DIVISIBLE, /**< divisibility-by-k predicate */
  POW, /**< arithmetic power */
  DIVISIBLE_OP, /**< operator for the divisibility-by-k predicate */
  SUBRANGE_TYPE, /**< the type of an integer subrange */
  CONST_RATIONAL, /**< a multiple-precision rational constant */
  LT, /**< less than, x < y */
  LEQ, /**< less than or equal, x <= y */
  GT, /**< greater than, x > y */
  GEQ, /**< greater than or equal, x >= y */
  IS_INTEGER, /**< term is integer */
  TO_INTEGER, /**< cast term to integer */
  TO_REAL, /**< cast term to real */

  /* from bv */
  BITVECTOR_TYPE, /**< bit-vector type */
  CONST_BITVECTOR, /**< a fixed-width bit-vector constant */
  BITVECTOR_CONCAT, /**< bit-vector concatenation */
  BITVECTOR_AND, /**< bitwise and */
  BITVECTOR_OR, /**< bitwise or */
  BITVECTOR_XOR, /**< bitwise xor */
  BITVECTOR_NOT, /**< bitwise not */
  BITVECTOR_NAND, /**< bitwise nand */
  BITVECTOR_NOR, /**< bitwise nor */
  BITVECTOR_XNOR, /**< bitwise xnor */
  BITVECTOR_COMP, /**< equality comparison (returns one bit) */
  BITVECTOR_MULT, /**< bit-vector multiplication */
  BITVECTOR_PLUS, /**< bit-vector addition */
  BITVECTOR_SUB, /**< bit-vector subtraction */
  BITVECTOR_NEG, /**< bit-vector unary negation */
  BITVECTOR_UDIV, /**< bit-vector unsigned division, truncating towards 0 (undefined if divisor is 0) */
  BITVECTOR_UREM, /**< bit-vector unsigned remainder from truncating division (undefined if divisor is 0) */
  BITVECTOR_SDIV, /**< bit-vector 2's complement signed division */
  BITVECTOR_SREM, /**< bit-vector 2's complement signed remainder (sign follows dividend) */
  BITVECTOR_SMOD, /**< bit-vector 2's complement signed remainder (sign follows divisor) */
  BITVECTOR_UDIV_TOTAL, /**< bit-vector total unsigned division, truncating towards 0 (undefined if divisor is 0) */
  BITVECTOR_UREM_TOTAL, /**< bit-vector total unsigned remainder from truncating division (undefined if divisor is 0) */
  BITVECTOR_SHL, /**< bit-vector left shift */
  BITVECTOR_LSHR, /**< bit-vector logical shift right */
  BITVECTOR_ASHR, /**< bit-vector arithmetic shift right */
  BITVECTOR_ULT, /**< bit-vector unsigned less than */
  BITVECTOR_ULE, /**< bit-vector unsigned less than or equal */
  BITVECTOR_UGT, /**< bit-vector unsigned greater than */
  BITVECTOR_UGE, /**< bit-vector unsigned greater than or equal */
  BITVECTOR_SLT, /**< bit-vector signed less than */
  BITVECTOR_SLE, /**< bit-vector signed less than or equal */
  BITVECTOR_SGT, /**< bit-vector signed greater than */
  BITVECTOR_SGE, /**< signed greater than or equal */
  BITVECTOR_BITOF_OP, /**< operator for the bit-vector boolean bit extract */
  BITVECTOR_EXTRACT_OP, /**< operator for the bit-vector extract */
  BITVECTOR_REPEAT_OP, /**< operator for the bit-vector repeat */
  BITVECTOR_ZERO_EXTEND_OP, /**< operator for the bit-vector zero-extend */
  BITVECTOR_SIGN_EXTEND_OP, /**< operator for the bit-vector sign-extend */
  BITVECTOR_ROTATE_LEFT_OP, /**< operator for the bit-vector rotate left */
  BITVECTOR_ROTATE_RIGHT_OP, /**< operator for the bit-vector rotate right */
  BITVECTOR_BITOF, /**< bit-vector boolean bit extract */
  BITVECTOR_EXTRACT, /**< bit-vector extract */
  BITVECTOR_REPEAT, /**< bit-vector repeat */
  BITVECTOR_ZERO_EXTEND, /**< bit-vector zero-extend */
  BITVECTOR_SIGN_EXTEND, /**< bit-vector sign-extend */
  BITVECTOR_ROTATE_LEFT, /**< bit-vector rotate left */
  BITVECTOR_ROTATE_RIGHT, /**< bit-vector rotate right */
  INT_TO_BITVECTOR_OP, /**< operator for the integer conversion to bit-vector */
  INT_TO_BITVECTOR, /**< integer conversion to bit-vector */
  BITVECTOR_TO_NAT, /**< bit-vector conversion to (nonnegative) integer */

  /* from arrays */
  ARRAY_TYPE, /**< array type */
  SELECT, /**< array select */
  STORE, /**< array store */
  STORE_ALL, /**< array store-all */
  ARR_TABLE_FUN, /**< array table function (internal symbol) */

  /* from datatypes */
  CONSTRUCTOR_TYPE, /**< constructor */
  SELECTOR_TYPE, /**< selector */
  TESTER_TYPE, /**< tester */
  APPLY_CONSTRUCTOR, /**< constructor application */
  APPLY_SELECTOR, /**< selector application */
  APPLY_TESTER, /**< tester application */
  DATATYPE_TYPE, /**< datatype type */
  PARAMETRIC_DATATYPE, /**< parametric datatype */
  APPLY_TYPE_ASCRIPTION, /**< type ascription, for datatype constructor applications */
  ASCRIPTION_TYPE, /**< a type parameter for type ascription */
  TUPLE_TYPE, /**< tuple type */
  TUPLE, /**< a tuple */
  TUPLE_SELECT_OP, /**< operator for a tuple select */
  TUPLE_SELECT, /**< tuple select */
  TUPLE_UPDATE_OP, /**< operator for a tuple update */
  TUPLE_UPDATE, /**< tuple update */
  RECORD_TYPE, /**< record type */
  RECORD, /**< a record */
  RECORD_SELECT_OP, /**< operator for a record select */
  RECORD_SELECT, /**< record select */
  RECORD_UPDATE_OP, /**< operator for a record update */
  RECORD_UPDATE, /**< record update */

  /* from quantifiers */
  FORALL, /**< universally quantified formula */
  EXISTS, /**< existentially quantified formula */
  INST_CONSTANT, /**< instantiation constant */
  BOUND_VAR_LIST, /**< bound variables */
  INST_PATTERN, /**< instantiation pattern */
  INST_PATTERN_LIST, /**< instantiation pattern list */

  /* from rewriterules */
  REWRITE_RULE, /**< general rewrite rule */
  RR_REWRITE, /**< actual rewrite rule */
  RR_REDUCTION, /**< actual reduction rule */
  RR_DEDUCTION, /**< actual deduction rule */

  /* from idl */

  /* from strings */
  STRING_CONCAT, /**< string concat */
  STRING_IN_REGEXP, /**< membership */
  STRING_LENGTH, /**< string length */
  STRING_SUBSTR, /**< string substr */
  CONST_STRING, /**< a string of characters */
  CONST_REGEXP, /**< a regular expression */
  STRING_TO_REGEXP, /**< convert string to regexp */
  REGEXP_CONCAT, /**< regexp concat */
  REGEXP_OR, /**< regexp or */
  REGEXP_INTER, /**< regexp intersection */
  REGEXP_STAR, /**< regexp * */
  REGEXP_PLUS, /**< regexp + */
  REGEXP_OPT, /**< regexp ? */
  REGEXP_RANGE, /**< regexp range */

  LAST_KIND /**< marks the upper-bound of this enumeration */

}; /* enum Kind_t */

}/* CVC4::kind namespace */

// import Kind into the "CVC4" namespace but keep the individual kind
// constants under kind::
typedef ::CVC4::kind::Kind_t Kind;

namespace kind {

inline std::ostream& operator<< (std::ostream&, CVC4::Kind) CVC4_PUBLIC;

inline std::ostream& operator<< (std::ostream& out, CVC4::Kind k) {
  using namespace CVC4::kind;

  switch (k) {

    /* special cases */
  case UNDEFINED_KIND: out << "UNDEFINED_KIND";
    break;
  case NULL_EXPR: out << "NULL";
    break;

    /* from builtin */
  case SORT_TAG: out << "SORT_TAG";
    break;
  case SORT_TYPE: out << "SORT_TYPE";
    break;
  case UNINTERPRETED_CONSTANT: out << "UNINTERPRETED_CONSTANT";
    break;
  case ABSTRACT_VALUE: out << "ABSTRACT_VALUE";
    break;
  case BUILTIN: out << "BUILTIN";
    break;
  case FUNCTION: out << "FUNCTION";
    break;
  case APPLY: out << "APPLY";
    break;
  case EQUAL: out << "EQUAL";
    break;
  case DISTINCT: out << "DISTINCT";
    break;
  case VARIABLE: out << "VARIABLE";
    break;
  case BOUND_VARIABLE: out << "BOUND_VARIABLE";
    break;
  case SKOLEM: out << "SKOLEM";
    break;
  case SEXPR: out << "SEXPR";
    break;
  case LAMBDA: out << "LAMBDA";
    break;
  case CHAIN: out << "CHAIN";
    break;
  case CHAIN_OP: out << "CHAIN_OP";
    break;
  case TYPE_CONSTANT: out << "TYPE_CONSTANT";
    break;
  case FUNCTION_TYPE: out << "FUNCTION_TYPE";
    break;
  case SEXPR_TYPE: out << "SEXPR_TYPE";
    break;
  case SUBTYPE_TYPE: out << "SUBTYPE_TYPE";
    break;

    /* from booleans */
  case CONST_BOOLEAN: out << "CONST_BOOLEAN";
    break;
  case NOT: out << "NOT";
    break;
  case AND: out << "AND";
    break;
  case IFF: out << "IFF";
    break;
  case IMPLIES: out << "IMPLIES";
    break;
  case OR: out << "OR";
    break;
  case XOR: out << "XOR";
    break;
  case ITE: out << "ITE";
    break;

    /* from uf */
  case APPLY_UF: out << "APPLY_UF";
    break;
  case CARDINALITY_CONSTRAINT: out << "CARDINALITY_CONSTRAINT";
    break;
  case COMBINED_CARDINALITY_CONSTRAINT: out << "COMBINED_CARDINALITY_CONSTRAINT";
    break;

    /* from arith */
  case PLUS: out << "PLUS";
    break;
  case MULT: out << "MULT";
    break;
  case MINUS: out << "MINUS";
    break;
  case UMINUS: out << "UMINUS";
    break;
  case DIVISION: out << "DIVISION";
    break;
  case DIVISION_TOTAL: out << "DIVISION_TOTAL";
    break;
  case INTS_DIVISION: out << "INTS_DIVISION";
    break;
  case INTS_DIVISION_TOTAL: out << "INTS_DIVISION_TOTAL";
    break;
  case INTS_MODULUS: out << "INTS_MODULUS";
    break;
  case INTS_MODULUS_TOTAL: out << "INTS_MODULUS_TOTAL";
    break;
  case ABS: out << "ABS";
    break;
  case DIVISIBLE: out << "DIVISIBLE";
    break;
  case POW: out << "POW";
    break;
  case DIVISIBLE_OP: out << "DIVISIBLE_OP";
    break;
  case SUBRANGE_TYPE: out << "SUBRANGE_TYPE";
    break;
  case CONST_RATIONAL: out << "CONST_RATIONAL";
    break;
  case LT: out << "LT";
    break;
  case LEQ: out << "LEQ";
    break;
  case GT: out << "GT";
    break;
  case GEQ: out << "GEQ";
    break;
  case IS_INTEGER: out << "IS_INTEGER";
    break;
  case TO_INTEGER: out << "TO_INTEGER";
    break;
  case TO_REAL: out << "TO_REAL";
    break;

    /* from bv */
  case BITVECTOR_TYPE: out << "BITVECTOR_TYPE";
    break;
  case CONST_BITVECTOR: out << "CONST_BITVECTOR";
    break;
  case BITVECTOR_CONCAT: out << "BITVECTOR_CONCAT";
    break;
  case BITVECTOR_AND: out << "BITVECTOR_AND";
    break;
  case BITVECTOR_OR: out << "BITVECTOR_OR";
    break;
  case BITVECTOR_XOR: out << "BITVECTOR_XOR";
    break;
  case BITVECTOR_NOT: out << "BITVECTOR_NOT";
    break;
  case BITVECTOR_NAND: out << "BITVECTOR_NAND";
    break;
  case BITVECTOR_NOR: out << "BITVECTOR_NOR";
    break;
  case BITVECTOR_XNOR: out << "BITVECTOR_XNOR";
    break;
  case BITVECTOR_COMP: out << "BITVECTOR_COMP";
    break;
  case BITVECTOR_MULT: out << "BITVECTOR_MULT";
    break;
  case BITVECTOR_PLUS: out << "BITVECTOR_PLUS";
    break;
  case BITVECTOR_SUB: out << "BITVECTOR_SUB";
    break;
  case BITVECTOR_NEG: out << "BITVECTOR_NEG";
    break;
  case BITVECTOR_UDIV: out << "BITVECTOR_UDIV";
    break;
  case BITVECTOR_UREM: out << "BITVECTOR_UREM";
    break;
  case BITVECTOR_SDIV: out << "BITVECTOR_SDIV";
    break;
  case BITVECTOR_SREM: out << "BITVECTOR_SREM";
    break;
  case BITVECTOR_SMOD: out << "BITVECTOR_SMOD";
    break;
  case BITVECTOR_UDIV_TOTAL: out << "BITVECTOR_UDIV_TOTAL";
    break;
  case BITVECTOR_UREM_TOTAL: out << "BITVECTOR_UREM_TOTAL";
    break;
  case BITVECTOR_SHL: out << "BITVECTOR_SHL";
    break;
  case BITVECTOR_LSHR: out << "BITVECTOR_LSHR";
    break;
  case BITVECTOR_ASHR: out << "BITVECTOR_ASHR";
    break;
  case BITVECTOR_ULT: out << "BITVECTOR_ULT";
    break;
  case BITVECTOR_ULE: out << "BITVECTOR_ULE";
    break;
  case BITVECTOR_UGT: out << "BITVECTOR_UGT";
    break;
  case BITVECTOR_UGE: out << "BITVECTOR_UGE";
    break;
  case BITVECTOR_SLT: out << "BITVECTOR_SLT";
    break;
  case BITVECTOR_SLE: out << "BITVECTOR_SLE";
    break;
  case BITVECTOR_SGT: out << "BITVECTOR_SGT";
    break;
  case BITVECTOR_SGE: out << "BITVECTOR_SGE";
    break;
  case BITVECTOR_BITOF_OP: out << "BITVECTOR_BITOF_OP";
    break;
  case BITVECTOR_EXTRACT_OP: out << "BITVECTOR_EXTRACT_OP";
    break;
  case BITVECTOR_REPEAT_OP: out << "BITVECTOR_REPEAT_OP";
    break;
  case BITVECTOR_ZERO_EXTEND_OP: out << "BITVECTOR_ZERO_EXTEND_OP";
    break;
  case BITVECTOR_SIGN_EXTEND_OP: out << "BITVECTOR_SIGN_EXTEND_OP";
    break;
  case BITVECTOR_ROTATE_LEFT_OP: out << "BITVECTOR_ROTATE_LEFT_OP";
    break;
  case BITVECTOR_ROTATE_RIGHT_OP: out << "BITVECTOR_ROTATE_RIGHT_OP";
    break;
  case BITVECTOR_BITOF: out << "BITVECTOR_BITOF";
    break;
  case BITVECTOR_EXTRACT: out << "BITVECTOR_EXTRACT";
    break;
  case BITVECTOR_REPEAT: out << "BITVECTOR_REPEAT";
    break;
  case BITVECTOR_ZERO_EXTEND: out << "BITVECTOR_ZERO_EXTEND";
    break;
  case BITVECTOR_SIGN_EXTEND: out << "BITVECTOR_SIGN_EXTEND";
    break;
  case BITVECTOR_ROTATE_LEFT: out << "BITVECTOR_ROTATE_LEFT";
    break;
  case BITVECTOR_ROTATE_RIGHT: out << "BITVECTOR_ROTATE_RIGHT";
    break;
  case INT_TO_BITVECTOR_OP: out << "INT_TO_BITVECTOR_OP";
    break;
  case INT_TO_BITVECTOR: out << "INT_TO_BITVECTOR";
    break;
  case BITVECTOR_TO_NAT: out << "BITVECTOR_TO_NAT";
    break;

    /* from arrays */
  case ARRAY_TYPE: out << "ARRAY_TYPE";
    break;
  case SELECT: out << "SELECT";
    break;
  case STORE: out << "STORE";
    break;
  case STORE_ALL: out << "STORE_ALL";
    break;
  case ARR_TABLE_FUN: out << "ARR_TABLE_FUN";
    break;

    /* from datatypes */
  case CONSTRUCTOR_TYPE: out << "CONSTRUCTOR_TYPE";
    break;
  case SELECTOR_TYPE: out << "SELECTOR_TYPE";
    break;
  case TESTER_TYPE: out << "TESTER_TYPE";
    break;
  case APPLY_CONSTRUCTOR: out << "APPLY_CONSTRUCTOR";
    break;
  case APPLY_SELECTOR: out << "APPLY_SELECTOR";
    break;
  case APPLY_TESTER: out << "APPLY_TESTER";
    break;
  case DATATYPE_TYPE: out << "DATATYPE_TYPE";
    break;
  case PARAMETRIC_DATATYPE: out << "PARAMETRIC_DATATYPE";
    break;
  case APPLY_TYPE_ASCRIPTION: out << "APPLY_TYPE_ASCRIPTION";
    break;
  case ASCRIPTION_TYPE: out << "ASCRIPTION_TYPE";
    break;
  case TUPLE_TYPE: out << "TUPLE_TYPE";
    break;
  case TUPLE: out << "TUPLE";
    break;
  case TUPLE_SELECT_OP: out << "TUPLE_SELECT_OP";
    break;
  case TUPLE_SELECT: out << "TUPLE_SELECT";
    break;
  case TUPLE_UPDATE_OP: out << "TUPLE_UPDATE_OP";
    break;
  case TUPLE_UPDATE: out << "TUPLE_UPDATE";
    break;
  case RECORD_TYPE: out << "RECORD_TYPE";
    break;
  case RECORD: out << "RECORD";
    break;
  case RECORD_SELECT_OP: out << "RECORD_SELECT_OP";
    break;
  case RECORD_SELECT: out << "RECORD_SELECT";
    break;
  case RECORD_UPDATE_OP: out << "RECORD_UPDATE_OP";
    break;
  case RECORD_UPDATE: out << "RECORD_UPDATE";
    break;

    /* from quantifiers */
  case FORALL: out << "FORALL";
    break;
  case EXISTS: out << "EXISTS";
    break;
  case INST_CONSTANT: out << "INST_CONSTANT";
    break;
  case BOUND_VAR_LIST: out << "BOUND_VAR_LIST";
    break;
  case INST_PATTERN: out << "INST_PATTERN";
    break;
  case INST_PATTERN_LIST: out << "INST_PATTERN_LIST";
    break;

    /* from rewriterules */
  case REWRITE_RULE: out << "REWRITE_RULE";
    break;
  case RR_REWRITE: out << "RR_REWRITE";
    break;
  case RR_REDUCTION: out << "RR_REDUCTION";
    break;
  case RR_DEDUCTION: out << "RR_DEDUCTION";
    break;

    /* from idl */

    /* from strings */
  case STRING_CONCAT: out << "STRING_CONCAT";
    break;
  case STRING_IN_REGEXP: out << "STRING_IN_REGEXP";
    break;
  case STRING_LENGTH: out << "STRING_LENGTH";
    break;
  case STRING_SUBSTR: out << "STRING_SUBSTR";
    break;
  case CONST_STRING: out << "CONST_STRING";
    break;
  case CONST_REGEXP: out << "CONST_REGEXP";
    break;
  case STRING_TO_REGEXP: out << "STRING_TO_REGEXP";
    break;
  case REGEXP_CONCAT: out << "REGEXP_CONCAT";
    break;
  case REGEXP_OR: out << "REGEXP_OR";
    break;
  case REGEXP_INTER: out << "REGEXP_INTER";
    break;
  case REGEXP_STAR: out << "REGEXP_STAR";
    break;
  case REGEXP_PLUS: out << "REGEXP_PLUS";
    break;
  case REGEXP_OPT: out << "REGEXP_OPT";
    break;
  case REGEXP_RANGE: out << "REGEXP_RANGE";
    break;

  case LAST_KIND: out << "LAST_KIND";
    break;
  default: out << "UNKNOWNKIND!" << int(k);
    break;
  }

  return out;
}

#line 64 "/home/behnam/installation-area/AUR/cvc4/src/cvc4-1.3/builds/x86_64-unknown-linux-gnu/default/../../../src/expr/kind_template.h"

/** Returns true if the given kind is associative. This is used by ExprManager to
 * decide whether it's safe to modify big expressions by changing the grouping of
 * the arguments. */

/* TODO: This could be generated. */
inline bool isAssociative (::CVC4::Kind k) {
  switch (k) {
  case kind::AND:
  case kind::OR:
  case kind::MULT:
  case kind::PLUS:
    return true;

  default:
    return false;
  }
}

inline std::string kindToString (::CVC4::Kind k) {
  std::stringstream ss;
  ss << k;
  return ss.str ();
}

struct KindHashFunction {

  inline size_t operator()(::CVC4::Kind k) const {
    return k;
  }
}; /* struct KindHashFunction */

}/* CVC4::kind namespace */

/**
 * The enumeration for the built-in atomic types.
 */
enum TypeConstant {

  BUILTIN_OPERATOR_TYPE, /**< Built in type for built in operators */
  BOOLEAN_TYPE, /**< Boolean type */
  REAL_TYPE, /**< Real type */
  INTEGER_TYPE, /**< Integer type */
  BOUND_VAR_LIST_TYPE, /**< Bound Var type */
  INST_PATTERN_TYPE, /**< Instantiation pattern type */
  INST_PATTERN_LIST_TYPE, /**< Instantiation pattern list type */
  RRHB_TYPE, /**< head and body of the rule type */
  STRING_TYPE, /**< String type */
  REGEXP_TYPE, /**< RegExp type */

#line 102 "/home/behnam/installation-area/AUR/cvc4/src/cvc4-1.3/builds/x86_64-unknown-linux-gnu/default/../../../src/expr/kind_template.h"
  LAST_TYPE
}; /* enum TypeConstant */

/**
 * We hash the constants with their values.
 */
struct TypeConstantHashFunction {

  inline size_t operator()(TypeConstant tc) const {
    return tc;
  }
}; /* struct TypeConstantHashFunction */

inline std::ostream& operator<< (std::ostream& out, TypeConstant typeConstant) {
  switch (typeConstant) {
  case BUILTIN_OPERATOR_TYPE: out << "Built in type for built in operators";
    break;
  case BOOLEAN_TYPE: out << "Boolean type";
    break;
  case REAL_TYPE: out << "Real type";
    break;
  case INTEGER_TYPE: out << "Integer type";
    break;
  case BOUND_VAR_LIST_TYPE: out << "Bound Var type";
    break;
  case INST_PATTERN_TYPE: out << "Instantiation pattern type";
    break;
  case INST_PATTERN_LIST_TYPE: out << "Instantiation pattern list type";
    break;
  case RRHB_TYPE: out << "head and body of the rule type";
    break;
  case STRING_TYPE: out << "String type";
    break;
  case REGEXP_TYPE: out << "RegExp type";
    break;

#line 118 "/home/behnam/installation-area/AUR/cvc4/src/cvc4-1.3/builds/x86_64-unknown-linux-gnu/default/../../../src/expr/kind_template.h"
  default:
    out << "UNKNOWN_TYPE_CONSTANT";
    break;
  }
  return out;
}

namespace theory {

enum TheoryId {

  THEORY_BUILTIN,
  THEORY_BOOL,
  THEORY_UF,
  THEORY_ARITH,
  THEORY_BV,
  THEORY_ARRAY,
  THEORY_DATATYPES,
  THEORY_QUANTIFIERS,
  THEORY_REWRITERULES,
  THEORY_STRINGS,

#line 130 "/home/behnam/installation-area/AUR/cvc4/src/cvc4-1.3/builds/x86_64-unknown-linux-gnu/default/../../../src/expr/kind_template.h"
  THEORY_LAST
}; /* enum TheoryId */

const TheoryId THEORY_FIRST = static_cast<TheoryId> (0);
const TheoryId THEORY_SAT_SOLVER = THEORY_LAST;

inline TheoryId& operator ++ (TheoryId& id) {
  return id = static_cast<TheoryId> (((int) id) + 1);
}

inline std::ostream& operator<< (std::ostream& out, TheoryId theoryId) {
  switch (theoryId) {
  case THEORY_BUILTIN: out << "THEORY_BUILTIN";
    break;
  case THEORY_BOOL: out << "THEORY_BOOL";
    break;
  case THEORY_UF: out << "THEORY_UF";
    break;
  case THEORY_ARITH: out << "THEORY_ARITH";
    break;
  case THEORY_BV: out << "THEORY_BV";
    break;
  case THEORY_ARRAY: out << "THEORY_ARRAY";
    break;
  case THEORY_DATATYPES: out << "THEORY_DATATYPES";
    break;
  case THEORY_QUANTIFIERS: out << "THEORY_QUANTIFIERS";
    break;
  case THEORY_REWRITERULES: out << "THEORY_REWRITERULES";
    break;
  case THEORY_STRINGS: out << "THEORY_STRINGS";
    break;

#line 144 "/home/behnam/installation-area/AUR/cvc4/src/cvc4-1.3/builds/x86_64-unknown-linux-gnu/default/../../../src/expr/kind_template.h"
  default:
    out << "UNKNOWN_THEORY";
    break;
  }
  return out;
}

inline TheoryId kindToTheoryId (::CVC4::Kind k) {
  switch (k) {
  case kind::UNDEFINED_KIND:
  case kind::NULL_EXPR:
    break;
  case kind::SORT_TAG: return THEORY_BUILTIN;
  case kind::SORT_TYPE: return THEORY_BUILTIN;
  case kind::UNINTERPRETED_CONSTANT: return THEORY_BUILTIN;
  case kind::ABSTRACT_VALUE: return THEORY_BUILTIN;
  case kind::BUILTIN: return THEORY_BUILTIN;
  case kind::FUNCTION: return THEORY_BUILTIN;
  case kind::APPLY: return THEORY_BUILTIN;
  case kind::EQUAL: return THEORY_BUILTIN;
  case kind::DISTINCT: return THEORY_BUILTIN;
  case kind::VARIABLE: return THEORY_BUILTIN;
  case kind::BOUND_VARIABLE: return THEORY_BUILTIN;
  case kind::SKOLEM: return THEORY_BUILTIN;
  case kind::SEXPR: return THEORY_BUILTIN;
  case kind::LAMBDA: return THEORY_BUILTIN;
  case kind::CHAIN: return THEORY_BUILTIN;
  case kind::CHAIN_OP: return THEORY_BUILTIN;
  case kind::TYPE_CONSTANT: return THEORY_BUILTIN;
  case kind::FUNCTION_TYPE: return THEORY_BUILTIN;
  case kind::SEXPR_TYPE: return THEORY_BUILTIN;
  case kind::SUBTYPE_TYPE: return THEORY_BUILTIN;
  case kind::CONST_BOOLEAN: return THEORY_BOOL;
  case kind::NOT: return THEORY_BOOL;
  case kind::AND: return THEORY_BOOL;
  case kind::IFF: return THEORY_BOOL;
  case kind::IMPLIES: return THEORY_BOOL;
  case kind::OR: return THEORY_BOOL;
  case kind::XOR: return THEORY_BOOL;
  case kind::ITE: return THEORY_BOOL;
  case kind::APPLY_UF: return THEORY_UF;
  case kind::CARDINALITY_CONSTRAINT: return THEORY_UF;
  case kind::COMBINED_CARDINALITY_CONSTRAINT: return THEORY_UF;
  case kind::PLUS: return THEORY_ARITH;
  case kind::MULT: return THEORY_ARITH;
  case kind::MINUS: return THEORY_ARITH;
  case kind::UMINUS: return THEORY_ARITH;
  case kind::DIVISION: return THEORY_ARITH;
  case kind::DIVISION_TOTAL: return THEORY_ARITH;
  case kind::INTS_DIVISION: return THEORY_ARITH;
  case kind::INTS_DIVISION_TOTAL: return THEORY_ARITH;
  case kind::INTS_MODULUS: return THEORY_ARITH;
  case kind::INTS_MODULUS_TOTAL: return THEORY_ARITH;
  case kind::ABS: return THEORY_ARITH;
  case kind::DIVISIBLE: return THEORY_ARITH;
  case kind::POW: return THEORY_ARITH;
  case kind::DIVISIBLE_OP: return THEORY_ARITH;
  case kind::SUBRANGE_TYPE: return THEORY_ARITH;
  case kind::CONST_RATIONAL: return THEORY_ARITH;
  case kind::LT: return THEORY_ARITH;
  case kind::LEQ: return THEORY_ARITH;
  case kind::GT: return THEORY_ARITH;
  case kind::GEQ: return THEORY_ARITH;
  case kind::IS_INTEGER: return THEORY_ARITH;
  case kind::TO_INTEGER: return THEORY_ARITH;
  case kind::TO_REAL: return THEORY_ARITH;
  case kind::BITVECTOR_TYPE: return THEORY_BV;
  case kind::CONST_BITVECTOR: return THEORY_BV;
  case kind::BITVECTOR_CONCAT: return THEORY_BV;
  case kind::BITVECTOR_AND: return THEORY_BV;
  case kind::BITVECTOR_OR: return THEORY_BV;
  case kind::BITVECTOR_XOR: return THEORY_BV;
  case kind::BITVECTOR_NOT: return THEORY_BV;
  case kind::BITVECTOR_NAND: return THEORY_BV;
  case kind::BITVECTOR_NOR: return THEORY_BV;
  case kind::BITVECTOR_XNOR: return THEORY_BV;
  case kind::BITVECTOR_COMP: return THEORY_BV;
  case kind::BITVECTOR_MULT: return THEORY_BV;
  case kind::BITVECTOR_PLUS: return THEORY_BV;
  case kind::BITVECTOR_SUB: return THEORY_BV;
  case kind::BITVECTOR_NEG: return THEORY_BV;
  case kind::BITVECTOR_UDIV: return THEORY_BV;
  case kind::BITVECTOR_UREM: return THEORY_BV;
  case kind::BITVECTOR_SDIV: return THEORY_BV;
  case kind::BITVECTOR_SREM: return THEORY_BV;
  case kind::BITVECTOR_SMOD: return THEORY_BV;
  case kind::BITVECTOR_UDIV_TOTAL: return THEORY_BV;
  case kind::BITVECTOR_UREM_TOTAL: return THEORY_BV;
  case kind::BITVECTOR_SHL: return THEORY_BV;
  case kind::BITVECTOR_LSHR: return THEORY_BV;
  case kind::BITVECTOR_ASHR: return THEORY_BV;
  case kind::BITVECTOR_ULT: return THEORY_BV;
  case kind::BITVECTOR_ULE: return THEORY_BV;
  case kind::BITVECTOR_UGT: return THEORY_BV;
  case kind::BITVECTOR_UGE: return THEORY_BV;
  case kind::BITVECTOR_SLT: return THEORY_BV;
  case kind::BITVECTOR_SLE: return THEORY_BV;
  case kind::BITVECTOR_SGT: return THEORY_BV;
  case kind::BITVECTOR_SGE: return THEORY_BV;
  case kind::BITVECTOR_BITOF_OP: return THEORY_BV;
  case kind::BITVECTOR_EXTRACT_OP: return THEORY_BV;
  case kind::BITVECTOR_REPEAT_OP: return THEORY_BV;
  case kind::BITVECTOR_ZERO_EXTEND_OP: return THEORY_BV;
  case kind::BITVECTOR_SIGN_EXTEND_OP: return THEORY_BV;
  case kind::BITVECTOR_ROTATE_LEFT_OP: return THEORY_BV;
  case kind::BITVECTOR_ROTATE_RIGHT_OP: return THEORY_BV;
  case kind::BITVECTOR_BITOF: return THEORY_BV;
  case kind::BITVECTOR_EXTRACT: return THEORY_BV;
  case kind::BITVECTOR_REPEAT: return THEORY_BV;
  case kind::BITVECTOR_ZERO_EXTEND: return THEORY_BV;
  case kind::BITVECTOR_SIGN_EXTEND: return THEORY_BV;
  case kind::BITVECTOR_ROTATE_LEFT: return THEORY_BV;
  case kind::BITVECTOR_ROTATE_RIGHT: return THEORY_BV;
  case kind::INT_TO_BITVECTOR_OP: return THEORY_BV;
  case kind::INT_TO_BITVECTOR: return THEORY_BV;
  case kind::BITVECTOR_TO_NAT: return THEORY_BV;
  case kind::ARRAY_TYPE: return THEORY_ARRAY;
  case kind::SELECT: return THEORY_ARRAY;
  case kind::STORE: return THEORY_ARRAY;
  case kind::STORE_ALL: return THEORY_ARRAY;
  case kind::ARR_TABLE_FUN: return THEORY_ARRAY;
  case kind::CONSTRUCTOR_TYPE: return THEORY_DATATYPES;
  case kind::SELECTOR_TYPE: return THEORY_DATATYPES;
  case kind::TESTER_TYPE: return THEORY_DATATYPES;
  case kind::APPLY_CONSTRUCTOR: return THEORY_DATATYPES;
  case kind::APPLY_SELECTOR: return THEORY_DATATYPES;
  case kind::APPLY_TESTER: return THEORY_DATATYPES;
  case kind::DATATYPE_TYPE: return THEORY_DATATYPES;
  case kind::PARAMETRIC_DATATYPE: return THEORY_DATATYPES;
  case kind::APPLY_TYPE_ASCRIPTION: return THEORY_DATATYPES;
  case kind::ASCRIPTION_TYPE: return THEORY_DATATYPES;
  case kind::TUPLE_TYPE: return THEORY_DATATYPES;
  case kind::TUPLE: return THEORY_DATATYPES;
  case kind::TUPLE_SELECT_OP: return THEORY_DATATYPES;
  case kind::TUPLE_SELECT: return THEORY_DATATYPES;
  case kind::TUPLE_UPDATE_OP: return THEORY_DATATYPES;
  case kind::TUPLE_UPDATE: return THEORY_DATATYPES;
  case kind::RECORD_TYPE: return THEORY_DATATYPES;
  case kind::RECORD: return THEORY_DATATYPES;
  case kind::RECORD_SELECT_OP: return THEORY_DATATYPES;
  case kind::RECORD_SELECT: return THEORY_DATATYPES;
  case kind::RECORD_UPDATE_OP: return THEORY_DATATYPES;
  case kind::RECORD_UPDATE: return THEORY_DATATYPES;
  case kind::FORALL: return THEORY_QUANTIFIERS;
  case kind::EXISTS: return THEORY_QUANTIFIERS;
  case kind::INST_CONSTANT: return THEORY_QUANTIFIERS;
  case kind::BOUND_VAR_LIST: return THEORY_QUANTIFIERS;
  case kind::INST_PATTERN: return THEORY_QUANTIFIERS;
  case kind::INST_PATTERN_LIST: return THEORY_QUANTIFIERS;
  case kind::REWRITE_RULE: return THEORY_REWRITERULES;
  case kind::RR_REWRITE: return THEORY_REWRITERULES;
  case kind::RR_REDUCTION: return THEORY_REWRITERULES;
  case kind::RR_DEDUCTION: return THEORY_REWRITERULES;
  case kind::STRING_CONCAT: return THEORY_STRINGS;
  case kind::STRING_IN_REGEXP: return THEORY_STRINGS;
  case kind::STRING_LENGTH: return THEORY_STRINGS;
  case kind::STRING_SUBSTR: return THEORY_STRINGS;
  case kind::CONST_STRING: return THEORY_STRINGS;
  case kind::CONST_REGEXP: return THEORY_STRINGS;
  case kind::STRING_TO_REGEXP: return THEORY_STRINGS;
  case kind::REGEXP_CONCAT: return THEORY_STRINGS;
  case kind::REGEXP_OR: return THEORY_STRINGS;
  case kind::REGEXP_INTER: return THEORY_STRINGS;
  case kind::REGEXP_STAR: return THEORY_STRINGS;
  case kind::REGEXP_PLUS: return THEORY_STRINGS;
  case kind::REGEXP_OPT: return THEORY_STRINGS;
  case kind::REGEXP_RANGE: return THEORY_STRINGS;

#line 158 "/home/behnam/installation-area/AUR/cvc4/src/cvc4-1.3/builds/x86_64-unknown-linux-gnu/default/../../../src/expr/kind_template.h"
  case kind::LAST_KIND:
    break;
  }
  throw IllegalArgumentException ("", "k", __PRETTY_FUNCTION__, "bad kind");
}

inline TheoryId typeConstantToTheoryId (::CVC4::TypeConstant typeConstant) {
  switch (typeConstant) {
  case BUILTIN_OPERATOR_TYPE: return THEORY_BUILTIN;
  case BOOLEAN_TYPE: return THEORY_BOOL;
  case REAL_TYPE: return THEORY_ARITH;
  case INTEGER_TYPE: return THEORY_ARITH;
  case BOUND_VAR_LIST_TYPE: return THEORY_QUANTIFIERS;
  case INST_PATTERN_TYPE: return THEORY_QUANTIFIERS;
  case INST_PATTERN_LIST_TYPE: return THEORY_QUANTIFIERS;
  case RRHB_TYPE: return THEORY_REWRITERULES;
  case STRING_TYPE: return THEORY_STRINGS;
  case REGEXP_TYPE: return THEORY_STRINGS;

#line 168 "/home/behnam/installation-area/AUR/cvc4/src/cvc4-1.3/builds/x86_64-unknown-linux-gnu/default/../../../src/expr/kind_template.h"
  case LAST_TYPE:
    break;
  }
  throw IllegalArgumentException ("", "k", __PRETTY_FUNCTION__, "bad type constant");
}

}/* CVC4::theory namespace */
}/* CVC4 namespace */

#endif /* __CVC4__KIND_H */
